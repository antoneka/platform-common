// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/antoneka/auth/pkg/client/db.Tx -o tx_minimock.go -n TxMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
)

// TxMock implements db.Tx
type TxMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBegin          func(ctx context.Context) (t1 pgx.Tx, err error)
	inspectFuncBegin   func(ctx context.Context)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mTxMockBegin

	funcBeginFunc          func(ctx context.Context, f func(pgx.Tx) error) (err error)
	inspectFuncBeginFunc   func(ctx context.Context, f func(pgx.Tx) error)
	afterBeginFuncCounter  uint64
	beforeBeginFuncCounter uint64
	BeginFuncMock          mTxMockBeginFunc

	funcCommit          func(ctx context.Context) (err error)
	inspectFuncCommit   func(ctx context.Context)
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mTxMockCommit

	funcConn          func() (cp1 *pgx.Conn)
	inspectFuncConn   func()
	afterConnCounter  uint64
	beforeConnCounter uint64
	ConnMock          mTxMockConn

	funcCopyFrom          func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (i1 int64, err error)
	inspectFuncCopyFrom   func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource)
	afterCopyFromCounter  uint64
	beforeCopyFromCounter uint64
	CopyFromMock          mTxMockCopyFrom

	funcExec          func(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error)
	inspectFuncExec   func(ctx context.Context, sql string, arguments ...interface{})
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mTxMockExec

	funcLargeObjects          func() (l1 pgx.LargeObjects)
	inspectFuncLargeObjects   func()
	afterLargeObjectsCounter  uint64
	beforeLargeObjectsCounter uint64
	LargeObjectsMock          mTxMockLargeObjects

	funcPrepare          func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)
	inspectFuncPrepare   func(ctx context.Context, name string, sql string)
	afterPrepareCounter  uint64
	beforePrepareCounter uint64
	PrepareMock          mTxMockPrepare

	funcQuery          func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Rows, err error)
	inspectFuncQuery   func(ctx context.Context, sql string, args ...interface{})
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mTxMockQuery

	funcQueryFunc          func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error)
	inspectFuncQueryFunc   func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error)
	afterQueryFuncCounter  uint64
	beforeQueryFuncCounter uint64
	QueryFuncMock          mTxMockQueryFunc

	funcQueryRow          func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row)
	inspectFuncQueryRow   func(ctx context.Context, sql string, args ...interface{})
	afterQueryRowCounter  uint64
	beforeQueryRowCounter uint64
	QueryRowMock          mTxMockQueryRow

	funcRollback          func(ctx context.Context) (err error)
	inspectFuncRollback   func(ctx context.Context)
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mTxMockRollback

	funcSendBatch          func(ctx context.Context, b *pgx.Batch) (b1 pgx.BatchResults)
	inspectFuncSendBatch   func(ctx context.Context, b *pgx.Batch)
	afterSendBatchCounter  uint64
	beforeSendBatchCounter uint64
	SendBatchMock          mTxMockSendBatch
}

// NewTxMock returns a mock for db.Tx
func NewTxMock(t minimock.Tester) *TxMock {
	m := &TxMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mTxMockBegin{mock: m}
	m.BeginMock.callArgs = []*TxMockBeginParams{}

	m.BeginFuncMock = mTxMockBeginFunc{mock: m}
	m.BeginFuncMock.callArgs = []*TxMockBeginFuncParams{}

	m.CommitMock = mTxMockCommit{mock: m}
	m.CommitMock.callArgs = []*TxMockCommitParams{}

	m.ConnMock = mTxMockConn{mock: m}

	m.CopyFromMock = mTxMockCopyFrom{mock: m}
	m.CopyFromMock.callArgs = []*TxMockCopyFromParams{}

	m.ExecMock = mTxMockExec{mock: m}
	m.ExecMock.callArgs = []*TxMockExecParams{}

	m.LargeObjectsMock = mTxMockLargeObjects{mock: m}

	m.PrepareMock = mTxMockPrepare{mock: m}
	m.PrepareMock.callArgs = []*TxMockPrepareParams{}

	m.QueryMock = mTxMockQuery{mock: m}
	m.QueryMock.callArgs = []*TxMockQueryParams{}

	m.QueryFuncMock = mTxMockQueryFunc{mock: m}
	m.QueryFuncMock.callArgs = []*TxMockQueryFuncParams{}

	m.QueryRowMock = mTxMockQueryRow{mock: m}
	m.QueryRowMock.callArgs = []*TxMockQueryRowParams{}

	m.RollbackMock = mTxMockRollback{mock: m}
	m.RollbackMock.callArgs = []*TxMockRollbackParams{}

	m.SendBatchMock = mTxMockSendBatch{mock: m}
	m.SendBatchMock.callArgs = []*TxMockSendBatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTxMockBegin struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockBeginExpectation
	expectations       []*TxMockBeginExpectation

	callArgs []*TxMockBeginParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockBeginExpectation specifies expectation struct of the Tx.Begin
type TxMockBeginExpectation struct {
	mock      *TxMock
	params    *TxMockBeginParams
	paramPtrs *TxMockBeginParamPtrs
	results   *TxMockBeginResults
	Counter   uint64
}

// TxMockBeginParams contains parameters of the Tx.Begin
type TxMockBeginParams struct {
	ctx context.Context
}

// TxMockBeginParamPtrs contains pointers to parameters of the Tx.Begin
type TxMockBeginParamPtrs struct {
	ctx *context.Context
}

// TxMockBeginResults contains results of the Tx.Begin
type TxMockBeginResults struct {
	t1  pgx.Tx
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBegin *mTxMockBegin) Optional() *mTxMockBegin {
	mmBegin.optional = true
	return mmBegin
}

// Expect sets up expected params for Tx.Begin
func (mmBegin *mTxMockBegin) Expect(ctx context.Context) *mTxMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TxMockBeginExpectation{}
	}

	if mmBegin.defaultExpectation.paramPtrs != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by ExpectParams functions")
	}

	mmBegin.defaultExpectation.params = &TxMockBeginParams{ctx}
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Begin
func (mmBegin *mTxMockBegin) ExpectCtxParam1(ctx context.Context) *mTxMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TxMockBeginExpectation{}
	}

	if mmBegin.defaultExpectation.params != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Expect")
	}

	if mmBegin.defaultExpectation.paramPtrs == nil {
		mmBegin.defaultExpectation.paramPtrs = &TxMockBeginParamPtrs{}
	}
	mmBegin.defaultExpectation.paramPtrs.ctx = &ctx

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the Tx.Begin
func (mmBegin *mTxMockBegin) Inspect(f func(ctx context.Context)) *mTxMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for TxMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by Tx.Begin
func (mmBegin *mTxMockBegin) Return(t1 pgx.Tx, err error) *TxMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TxMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &TxMockBeginResults{t1, err}
	return mmBegin.mock
}

// Set uses given function f to mock the Tx.Begin method
func (mmBegin *mTxMockBegin) Set(f func(ctx context.Context) (t1 pgx.Tx, err error)) *TxMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the Tx.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the Tx.Begin method")
	}

	mmBegin.mock.funcBegin = f
	return mmBegin.mock
}

// When sets expectation for the Tx.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mTxMockBegin) When(ctx context.Context) *TxMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	expectation := &TxMockBeginExpectation{
		mock:   mmBegin.mock,
		params: &TxMockBeginParams{ctx},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up Tx.Begin return parameters for the expectation previously defined by the When method
func (e *TxMockBeginExpectation) Then(t1 pgx.Tx, err error) *TxMock {
	e.results = &TxMockBeginResults{t1, err}
	return e.mock
}

// Times sets number of times Tx.Begin should be invoked
func (mmBegin *mTxMockBegin) Times(n uint64) *mTxMockBegin {
	if n == 0 {
		mmBegin.mock.t.Fatalf("Times of TxMock.Begin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBegin.expectedInvocations, n)
	return mmBegin
}

func (mmBegin *mTxMockBegin) invocationsDone() bool {
	if len(mmBegin.expectations) == 0 && mmBegin.defaultExpectation == nil && mmBegin.mock.funcBegin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBegin.mock.afterBeginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBegin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Begin implements db.Tx
func (mmBegin *TxMock) Begin(ctx context.Context) (t1 pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx)
	}

	mm_params := TxMockBeginParams{ctx}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, &mm_params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		mm_want := mmBegin.BeginMock.defaultExpectation.params
		mm_want_ptrs := mmBegin.BeginMock.defaultExpectation.paramPtrs

		mm_got := TxMockBeginParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBegin.t.Errorf("TxMock.Begin got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBegin.t.Errorf("TxMock.Begin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the TxMock.Begin")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx)
	}
	mmBegin.t.Fatalf("Unexpected call to TxMock.Begin. %v", ctx)
	return
}

// BeginAfterCounter returns a count of finished TxMock.Begin invocations
func (mmBegin *TxMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of TxMock.Begin invocations
func (mmBegin *TxMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mTxMockBegin) Calls() []*TxMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*TxMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockBeginDone() bool {
	if m.BeginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginMock.invocationsDone()
}

// MinimockBeginInspect logs each unmet expectation
func (m *TxMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Begin with params: %#v", *e.params)
		}
	}

	afterBeginCounter := mm_atomic.LoadUint64(&m.afterBeginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && afterBeginCounter < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Begin")
		} else {
			m.t.Errorf("Expected call to TxMock.Begin with params: %#v", *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && afterBeginCounter < 1 {
		m.t.Error("Expected call to TxMock.Begin")
	}

	if !m.BeginMock.invocationsDone() && afterBeginCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Begin but found %d calls",
			mm_atomic.LoadUint64(&m.BeginMock.expectedInvocations), afterBeginCounter)
	}
}

type mTxMockBeginFunc struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockBeginFuncExpectation
	expectations       []*TxMockBeginFuncExpectation

	callArgs []*TxMockBeginFuncParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockBeginFuncExpectation specifies expectation struct of the Tx.BeginFunc
type TxMockBeginFuncExpectation struct {
	mock      *TxMock
	params    *TxMockBeginFuncParams
	paramPtrs *TxMockBeginFuncParamPtrs
	results   *TxMockBeginFuncResults
	Counter   uint64
}

// TxMockBeginFuncParams contains parameters of the Tx.BeginFunc
type TxMockBeginFuncParams struct {
	ctx context.Context
	f   func(pgx.Tx) error
}

// TxMockBeginFuncParamPtrs contains pointers to parameters of the Tx.BeginFunc
type TxMockBeginFuncParamPtrs struct {
	ctx *context.Context
	f   *func(pgx.Tx) error
}

// TxMockBeginFuncResults contains results of the Tx.BeginFunc
type TxMockBeginFuncResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBeginFunc *mTxMockBeginFunc) Optional() *mTxMockBeginFunc {
	mmBeginFunc.optional = true
	return mmBeginFunc
}

// Expect sets up expected params for Tx.BeginFunc
func (mmBeginFunc *mTxMockBeginFunc) Expect(ctx context.Context, f func(pgx.Tx) error) *mTxMockBeginFunc {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TxMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &TxMockBeginFuncExpectation{}
	}

	if mmBeginFunc.defaultExpectation.paramPtrs != nil {
		mmBeginFunc.mock.t.Fatalf("TxMock.BeginFunc mock is already set by ExpectParams functions")
	}

	mmBeginFunc.defaultExpectation.params = &TxMockBeginFuncParams{ctx, f}
	for _, e := range mmBeginFunc.expectations {
		if minimock.Equal(e.params, mmBeginFunc.defaultExpectation.params) {
			mmBeginFunc.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBeginFunc.defaultExpectation.params)
		}
	}

	return mmBeginFunc
}

// ExpectCtxParam1 sets up expected param ctx for Tx.BeginFunc
func (mmBeginFunc *mTxMockBeginFunc) ExpectCtxParam1(ctx context.Context) *mTxMockBeginFunc {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TxMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &TxMockBeginFuncExpectation{}
	}

	if mmBeginFunc.defaultExpectation.params != nil {
		mmBeginFunc.mock.t.Fatalf("TxMock.BeginFunc mock is already set by Expect")
	}

	if mmBeginFunc.defaultExpectation.paramPtrs == nil {
		mmBeginFunc.defaultExpectation.paramPtrs = &TxMockBeginFuncParamPtrs{}
	}
	mmBeginFunc.defaultExpectation.paramPtrs.ctx = &ctx

	return mmBeginFunc
}

// ExpectFParam2 sets up expected param f for Tx.BeginFunc
func (mmBeginFunc *mTxMockBeginFunc) ExpectFParam2(f func(pgx.Tx) error) *mTxMockBeginFunc {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TxMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &TxMockBeginFuncExpectation{}
	}

	if mmBeginFunc.defaultExpectation.params != nil {
		mmBeginFunc.mock.t.Fatalf("TxMock.BeginFunc mock is already set by Expect")
	}

	if mmBeginFunc.defaultExpectation.paramPtrs == nil {
		mmBeginFunc.defaultExpectation.paramPtrs = &TxMockBeginFuncParamPtrs{}
	}
	mmBeginFunc.defaultExpectation.paramPtrs.f = &f

	return mmBeginFunc
}

// Inspect accepts an inspector function that has same arguments as the Tx.BeginFunc
func (mmBeginFunc *mTxMockBeginFunc) Inspect(f func(ctx context.Context, f func(pgx.Tx) error)) *mTxMockBeginFunc {
	if mmBeginFunc.mock.inspectFuncBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("Inspect function is already set for TxMock.BeginFunc")
	}

	mmBeginFunc.mock.inspectFuncBeginFunc = f

	return mmBeginFunc
}

// Return sets up results that will be returned by Tx.BeginFunc
func (mmBeginFunc *mTxMockBeginFunc) Return(err error) *TxMock {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TxMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &TxMockBeginFuncExpectation{mock: mmBeginFunc.mock}
	}
	mmBeginFunc.defaultExpectation.results = &TxMockBeginFuncResults{err}
	return mmBeginFunc.mock
}

// Set uses given function f to mock the Tx.BeginFunc method
func (mmBeginFunc *mTxMockBeginFunc) Set(f func(ctx context.Context, f func(pgx.Tx) error) (err error)) *TxMock {
	if mmBeginFunc.defaultExpectation != nil {
		mmBeginFunc.mock.t.Fatalf("Default expectation is already set for the Tx.BeginFunc method")
	}

	if len(mmBeginFunc.expectations) > 0 {
		mmBeginFunc.mock.t.Fatalf("Some expectations are already set for the Tx.BeginFunc method")
	}

	mmBeginFunc.mock.funcBeginFunc = f
	return mmBeginFunc.mock
}

// When sets expectation for the Tx.BeginFunc which will trigger the result defined by the following
// Then helper
func (mmBeginFunc *mTxMockBeginFunc) When(ctx context.Context, f func(pgx.Tx) error) *TxMockBeginFuncExpectation {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TxMock.BeginFunc mock is already set by Set")
	}

	expectation := &TxMockBeginFuncExpectation{
		mock:   mmBeginFunc.mock,
		params: &TxMockBeginFuncParams{ctx, f},
	}
	mmBeginFunc.expectations = append(mmBeginFunc.expectations, expectation)
	return expectation
}

// Then sets up Tx.BeginFunc return parameters for the expectation previously defined by the When method
func (e *TxMockBeginFuncExpectation) Then(err error) *TxMock {
	e.results = &TxMockBeginFuncResults{err}
	return e.mock
}

// Times sets number of times Tx.BeginFunc should be invoked
func (mmBeginFunc *mTxMockBeginFunc) Times(n uint64) *mTxMockBeginFunc {
	if n == 0 {
		mmBeginFunc.mock.t.Fatalf("Times of TxMock.BeginFunc mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBeginFunc.expectedInvocations, n)
	return mmBeginFunc
}

func (mmBeginFunc *mTxMockBeginFunc) invocationsDone() bool {
	if len(mmBeginFunc.expectations) == 0 && mmBeginFunc.defaultExpectation == nil && mmBeginFunc.mock.funcBeginFunc == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBeginFunc.mock.afterBeginFuncCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBeginFunc.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BeginFunc implements db.Tx
func (mmBeginFunc *TxMock) BeginFunc(ctx context.Context, f func(pgx.Tx) error) (err error) {
	mm_atomic.AddUint64(&mmBeginFunc.beforeBeginFuncCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginFunc.afterBeginFuncCounter, 1)

	if mmBeginFunc.inspectFuncBeginFunc != nil {
		mmBeginFunc.inspectFuncBeginFunc(ctx, f)
	}

	mm_params := TxMockBeginFuncParams{ctx, f}

	// Record call args
	mmBeginFunc.BeginFuncMock.mutex.Lock()
	mmBeginFunc.BeginFuncMock.callArgs = append(mmBeginFunc.BeginFuncMock.callArgs, &mm_params)
	mmBeginFunc.BeginFuncMock.mutex.Unlock()

	for _, e := range mmBeginFunc.BeginFuncMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmBeginFunc.BeginFuncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginFunc.BeginFuncMock.defaultExpectation.Counter, 1)
		mm_want := mmBeginFunc.BeginFuncMock.defaultExpectation.params
		mm_want_ptrs := mmBeginFunc.BeginFuncMock.defaultExpectation.paramPtrs

		mm_got := TxMockBeginFuncParams{ctx, f}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBeginFunc.t.Errorf("TxMock.BeginFunc got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.f != nil && !minimock.Equal(*mm_want_ptrs.f, mm_got.f) {
				mmBeginFunc.t.Errorf("TxMock.BeginFunc got unexpected parameter f, want: %#v, got: %#v%s\n", *mm_want_ptrs.f, mm_got.f, minimock.Diff(*mm_want_ptrs.f, mm_got.f))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBeginFunc.t.Errorf("TxMock.BeginFunc got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBeginFunc.BeginFuncMock.defaultExpectation.results
		if mm_results == nil {
			mmBeginFunc.t.Fatal("No results are set for the TxMock.BeginFunc")
		}
		return (*mm_results).err
	}
	if mmBeginFunc.funcBeginFunc != nil {
		return mmBeginFunc.funcBeginFunc(ctx, f)
	}
	mmBeginFunc.t.Fatalf("Unexpected call to TxMock.BeginFunc. %v %v", ctx, f)
	return
}

// BeginFuncAfterCounter returns a count of finished TxMock.BeginFunc invocations
func (mmBeginFunc *TxMock) BeginFuncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginFunc.afterBeginFuncCounter)
}

// BeginFuncBeforeCounter returns a count of TxMock.BeginFunc invocations
func (mmBeginFunc *TxMock) BeginFuncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginFunc.beforeBeginFuncCounter)
}

// Calls returns a list of arguments used in each call to TxMock.BeginFunc.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBeginFunc *mTxMockBeginFunc) Calls() []*TxMockBeginFuncParams {
	mmBeginFunc.mutex.RLock()

	argCopy := make([]*TxMockBeginFuncParams, len(mmBeginFunc.callArgs))
	copy(argCopy, mmBeginFunc.callArgs)

	mmBeginFunc.mutex.RUnlock()

	return argCopy
}

// MinimockBeginFuncDone returns true if the count of the BeginFunc invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockBeginFuncDone() bool {
	if m.BeginFuncMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginFuncMock.invocationsDone()
}

// MinimockBeginFuncInspect logs each unmet expectation
func (m *TxMock) MinimockBeginFuncInspect() {
	for _, e := range m.BeginFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.BeginFunc with params: %#v", *e.params)
		}
	}

	afterBeginFuncCounter := mm_atomic.LoadUint64(&m.afterBeginFuncCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginFuncMock.defaultExpectation != nil && afterBeginFuncCounter < 1 {
		if m.BeginFuncMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.BeginFunc")
		} else {
			m.t.Errorf("Expected call to TxMock.BeginFunc with params: %#v", *m.BeginFuncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginFunc != nil && afterBeginFuncCounter < 1 {
		m.t.Error("Expected call to TxMock.BeginFunc")
	}

	if !m.BeginFuncMock.invocationsDone() && afterBeginFuncCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.BeginFunc but found %d calls",
			mm_atomic.LoadUint64(&m.BeginFuncMock.expectedInvocations), afterBeginFuncCounter)
	}
}

type mTxMockCommit struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockCommitExpectation
	expectations       []*TxMockCommitExpectation

	callArgs []*TxMockCommitParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockCommitExpectation specifies expectation struct of the Tx.Commit
type TxMockCommitExpectation struct {
	mock      *TxMock
	params    *TxMockCommitParams
	paramPtrs *TxMockCommitParamPtrs
	results   *TxMockCommitResults
	Counter   uint64
}

// TxMockCommitParams contains parameters of the Tx.Commit
type TxMockCommitParams struct {
	ctx context.Context
}

// TxMockCommitParamPtrs contains pointers to parameters of the Tx.Commit
type TxMockCommitParamPtrs struct {
	ctx *context.Context
}

// TxMockCommitResults contains results of the Tx.Commit
type TxMockCommitResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommit *mTxMockCommit) Optional() *mTxMockCommit {
	mmCommit.optional = true
	return mmCommit
}

// Expect sets up expected params for Tx.Commit
func (mmCommit *mTxMockCommit) Expect(ctx context.Context) *mTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{}
	}

	if mmCommit.defaultExpectation.paramPtrs != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by ExpectParams functions")
	}

	mmCommit.defaultExpectation.params = &TxMockCommitParams{ctx}
	for _, e := range mmCommit.expectations {
		if minimock.Equal(e.params, mmCommit.defaultExpectation.params) {
			mmCommit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommit.defaultExpectation.params)
		}
	}

	return mmCommit
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Commit
func (mmCommit *mTxMockCommit) ExpectCtxParam1(ctx context.Context) *mTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{}
	}

	if mmCommit.defaultExpectation.params != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Expect")
	}

	if mmCommit.defaultExpectation.paramPtrs == nil {
		mmCommit.defaultExpectation.paramPtrs = &TxMockCommitParamPtrs{}
	}
	mmCommit.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the Tx.Commit
func (mmCommit *mTxMockCommit) Inspect(f func(ctx context.Context)) *mTxMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for TxMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by Tx.Commit
func (mmCommit *mTxMockCommit) Return(err error) *TxMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &TxMockCommitResults{err}
	return mmCommit.mock
}

// Set uses given function f to mock the Tx.Commit method
func (mmCommit *mTxMockCommit) Set(f func(ctx context.Context) (err error)) *TxMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the Tx.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the Tx.Commit method")
	}

	mmCommit.mock.funcCommit = f
	return mmCommit.mock
}

// When sets expectation for the Tx.Commit which will trigger the result defined by the following
// Then helper
func (mmCommit *mTxMockCommit) When(ctx context.Context) *TxMockCommitExpectation {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	expectation := &TxMockCommitExpectation{
		mock:   mmCommit.mock,
		params: &TxMockCommitParams{ctx},
	}
	mmCommit.expectations = append(mmCommit.expectations, expectation)
	return expectation
}

// Then sets up Tx.Commit return parameters for the expectation previously defined by the When method
func (e *TxMockCommitExpectation) Then(err error) *TxMock {
	e.results = &TxMockCommitResults{err}
	return e.mock
}

// Times sets number of times Tx.Commit should be invoked
func (mmCommit *mTxMockCommit) Times(n uint64) *mTxMockCommit {
	if n == 0 {
		mmCommit.mock.t.Fatalf("Times of TxMock.Commit mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommit.expectedInvocations, n)
	return mmCommit
}

func (mmCommit *mTxMockCommit) invocationsDone() bool {
	if len(mmCommit.expectations) == 0 && mmCommit.defaultExpectation == nil && mmCommit.mock.funcCommit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommit.mock.afterCommitCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Commit implements db.Tx
func (mmCommit *TxMock) Commit(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit(ctx)
	}

	mm_params := TxMockCommitParams{ctx}

	// Record call args
	mmCommit.CommitMock.mutex.Lock()
	mmCommit.CommitMock.callArgs = append(mmCommit.CommitMock.callArgs, &mm_params)
	mmCommit.CommitMock.mutex.Unlock()

	for _, e := range mmCommit.CommitMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)
		mm_want := mmCommit.CommitMock.defaultExpectation.params
		mm_want_ptrs := mmCommit.CommitMock.defaultExpectation.paramPtrs

		mm_got := TxMockCommitParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommit.t.Errorf("TxMock.Commit got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommit.t.Errorf("TxMock.Commit got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the TxMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit(ctx)
	}
	mmCommit.t.Fatalf("Unexpected call to TxMock.Commit. %v", ctx)
	return
}

// CommitAfterCounter returns a count of finished TxMock.Commit invocations
func (mmCommit *TxMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of TxMock.Commit invocations
func (mmCommit *TxMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Commit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommit *mTxMockCommit) Calls() []*TxMockCommitParams {
	mmCommit.mutex.RLock()

	argCopy := make([]*TxMockCommitParams, len(mmCommit.callArgs))
	copy(argCopy, mmCommit.callArgs)

	mmCommit.mutex.RUnlock()

	return argCopy
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockCommitDone() bool {
	if m.CommitMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommitMock.invocationsDone()
}

// MinimockCommitInspect logs each unmet expectation
func (m *TxMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Commit with params: %#v", *e.params)
		}
	}

	afterCommitCounter := mm_atomic.LoadUint64(&m.afterCommitCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && afterCommitCounter < 1 {
		if m.CommitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Commit")
		} else {
			m.t.Errorf("Expected call to TxMock.Commit with params: %#v", *m.CommitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && afterCommitCounter < 1 {
		m.t.Error("Expected call to TxMock.Commit")
	}

	if !m.CommitMock.invocationsDone() && afterCommitCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Commit but found %d calls",
			mm_atomic.LoadUint64(&m.CommitMock.expectedInvocations), afterCommitCounter)
	}
}

type mTxMockConn struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockConnExpectation
	expectations       []*TxMockConnExpectation

	expectedInvocations uint64
}

// TxMockConnExpectation specifies expectation struct of the Tx.Conn
type TxMockConnExpectation struct {
	mock *TxMock

	results *TxMockConnResults
	Counter uint64
}

// TxMockConnResults contains results of the Tx.Conn
type TxMockConnResults struct {
	cp1 *pgx.Conn
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConn *mTxMockConn) Optional() *mTxMockConn {
	mmConn.optional = true
	return mmConn
}

// Expect sets up expected params for Tx.Conn
func (mmConn *mTxMockConn) Expect() *mTxMockConn {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("TxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &TxMockConnExpectation{}
	}

	return mmConn
}

// Inspect accepts an inspector function that has same arguments as the Tx.Conn
func (mmConn *mTxMockConn) Inspect(f func()) *mTxMockConn {
	if mmConn.mock.inspectFuncConn != nil {
		mmConn.mock.t.Fatalf("Inspect function is already set for TxMock.Conn")
	}

	mmConn.mock.inspectFuncConn = f

	return mmConn
}

// Return sets up results that will be returned by Tx.Conn
func (mmConn *mTxMockConn) Return(cp1 *pgx.Conn) *TxMock {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("TxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &TxMockConnExpectation{mock: mmConn.mock}
	}
	mmConn.defaultExpectation.results = &TxMockConnResults{cp1}
	return mmConn.mock
}

// Set uses given function f to mock the Tx.Conn method
func (mmConn *mTxMockConn) Set(f func() (cp1 *pgx.Conn)) *TxMock {
	if mmConn.defaultExpectation != nil {
		mmConn.mock.t.Fatalf("Default expectation is already set for the Tx.Conn method")
	}

	if len(mmConn.expectations) > 0 {
		mmConn.mock.t.Fatalf("Some expectations are already set for the Tx.Conn method")
	}

	mmConn.mock.funcConn = f
	return mmConn.mock
}

// Times sets number of times Tx.Conn should be invoked
func (mmConn *mTxMockConn) Times(n uint64) *mTxMockConn {
	if n == 0 {
		mmConn.mock.t.Fatalf("Times of TxMock.Conn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConn.expectedInvocations, n)
	return mmConn
}

func (mmConn *mTxMockConn) invocationsDone() bool {
	if len(mmConn.expectations) == 0 && mmConn.defaultExpectation == nil && mmConn.mock.funcConn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConn.mock.afterConnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Conn implements db.Tx
func (mmConn *TxMock) Conn() (cp1 *pgx.Conn) {
	mm_atomic.AddUint64(&mmConn.beforeConnCounter, 1)
	defer mm_atomic.AddUint64(&mmConn.afterConnCounter, 1)

	if mmConn.inspectFuncConn != nil {
		mmConn.inspectFuncConn()
	}

	if mmConn.ConnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConn.ConnMock.defaultExpectation.Counter, 1)

		mm_results := mmConn.ConnMock.defaultExpectation.results
		if mm_results == nil {
			mmConn.t.Fatal("No results are set for the TxMock.Conn")
		}
		return (*mm_results).cp1
	}
	if mmConn.funcConn != nil {
		return mmConn.funcConn()
	}
	mmConn.t.Fatalf("Unexpected call to TxMock.Conn.")
	return
}

// ConnAfterCounter returns a count of finished TxMock.Conn invocations
func (mmConn *TxMock) ConnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.afterConnCounter)
}

// ConnBeforeCounter returns a count of TxMock.Conn invocations
func (mmConn *TxMock) ConnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.beforeConnCounter)
}

// MinimockConnDone returns true if the count of the Conn invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockConnDone() bool {
	if m.ConnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConnMock.invocationsDone()
}

// MinimockConnInspect logs each unmet expectation
func (m *TxMock) MinimockConnInspect() {
	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TxMock.Conn")
		}
	}

	afterConnCounter := mm_atomic.LoadUint64(&m.afterConnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConnMock.defaultExpectation != nil && afterConnCounter < 1 {
		m.t.Error("Expected call to TxMock.Conn")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConn != nil && afterConnCounter < 1 {
		m.t.Error("Expected call to TxMock.Conn")
	}

	if !m.ConnMock.invocationsDone() && afterConnCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Conn but found %d calls",
			mm_atomic.LoadUint64(&m.ConnMock.expectedInvocations), afterConnCounter)
	}
}

type mTxMockCopyFrom struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockCopyFromExpectation
	expectations       []*TxMockCopyFromExpectation

	callArgs []*TxMockCopyFromParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockCopyFromExpectation specifies expectation struct of the Tx.CopyFrom
type TxMockCopyFromExpectation struct {
	mock      *TxMock
	params    *TxMockCopyFromParams
	paramPtrs *TxMockCopyFromParamPtrs
	results   *TxMockCopyFromResults
	Counter   uint64
}

// TxMockCopyFromParams contains parameters of the Tx.CopyFrom
type TxMockCopyFromParams struct {
	ctx         context.Context
	tableName   pgx.Identifier
	columnNames []string
	rowSrc      pgx.CopyFromSource
}

// TxMockCopyFromParamPtrs contains pointers to parameters of the Tx.CopyFrom
type TxMockCopyFromParamPtrs struct {
	ctx         *context.Context
	tableName   *pgx.Identifier
	columnNames *[]string
	rowSrc      *pgx.CopyFromSource
}

// TxMockCopyFromResults contains results of the Tx.CopyFrom
type TxMockCopyFromResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCopyFrom *mTxMockCopyFrom) Optional() *mTxMockCopyFrom {
	mmCopyFrom.optional = true
	return mmCopyFrom
}

// Expect sets up expected params for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Expect(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.paramPtrs != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by ExpectParams functions")
	}

	mmCopyFrom.defaultExpectation.params = &TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}
	for _, e := range mmCopyFrom.expectations {
		if minimock.Equal(e.params, mmCopyFrom.defaultExpectation.params) {
			mmCopyFrom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyFrom.defaultExpectation.params)
		}
	}

	return mmCopyFrom
}

// ExpectCtxParam1 sets up expected param ctx for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectCtxParam1(ctx context.Context) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCopyFrom
}

// ExpectTableNameParam2 sets up expected param tableName for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectTableNameParam2(tableName pgx.Identifier) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.tableName = &tableName

	return mmCopyFrom
}

// ExpectColumnNamesParam3 sets up expected param columnNames for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectColumnNamesParam3(columnNames []string) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.columnNames = &columnNames

	return mmCopyFrom
}

// ExpectRowSrcParam4 sets up expected param rowSrc for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectRowSrcParam4(rowSrc pgx.CopyFromSource) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.rowSrc = &rowSrc

	return mmCopyFrom
}

// Inspect accepts an inspector function that has same arguments as the Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Inspect(f func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource)) *mTxMockCopyFrom {
	if mmCopyFrom.mock.inspectFuncCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("Inspect function is already set for TxMock.CopyFrom")
	}

	mmCopyFrom.mock.inspectFuncCopyFrom = f

	return mmCopyFrom
}

// Return sets up results that will be returned by Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Return(i1 int64, err error) *TxMock {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{mock: mmCopyFrom.mock}
	}
	mmCopyFrom.defaultExpectation.results = &TxMockCopyFromResults{i1, err}
	return mmCopyFrom.mock
}

// Set uses given function f to mock the Tx.CopyFrom method
func (mmCopyFrom *mTxMockCopyFrom) Set(f func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (i1 int64, err error)) *TxMock {
	if mmCopyFrom.defaultExpectation != nil {
		mmCopyFrom.mock.t.Fatalf("Default expectation is already set for the Tx.CopyFrom method")
	}

	if len(mmCopyFrom.expectations) > 0 {
		mmCopyFrom.mock.t.Fatalf("Some expectations are already set for the Tx.CopyFrom method")
	}

	mmCopyFrom.mock.funcCopyFrom = f
	return mmCopyFrom.mock
}

// When sets expectation for the Tx.CopyFrom which will trigger the result defined by the following
// Then helper
func (mmCopyFrom *mTxMockCopyFrom) When(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) *TxMockCopyFromExpectation {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	expectation := &TxMockCopyFromExpectation{
		mock:   mmCopyFrom.mock,
		params: &TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc},
	}
	mmCopyFrom.expectations = append(mmCopyFrom.expectations, expectation)
	return expectation
}

// Then sets up Tx.CopyFrom return parameters for the expectation previously defined by the When method
func (e *TxMockCopyFromExpectation) Then(i1 int64, err error) *TxMock {
	e.results = &TxMockCopyFromResults{i1, err}
	return e.mock
}

// Times sets number of times Tx.CopyFrom should be invoked
func (mmCopyFrom *mTxMockCopyFrom) Times(n uint64) *mTxMockCopyFrom {
	if n == 0 {
		mmCopyFrom.mock.t.Fatalf("Times of TxMock.CopyFrom mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCopyFrom.expectedInvocations, n)
	return mmCopyFrom
}

func (mmCopyFrom *mTxMockCopyFrom) invocationsDone() bool {
	if len(mmCopyFrom.expectations) == 0 && mmCopyFrom.defaultExpectation == nil && mmCopyFrom.mock.funcCopyFrom == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCopyFrom.mock.afterCopyFromCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCopyFrom.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CopyFrom implements db.Tx
func (mmCopyFrom *TxMock) CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCopyFrom.beforeCopyFromCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyFrom.afterCopyFromCounter, 1)

	if mmCopyFrom.inspectFuncCopyFrom != nil {
		mmCopyFrom.inspectFuncCopyFrom(ctx, tableName, columnNames, rowSrc)
	}

	mm_params := TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

	// Record call args
	mmCopyFrom.CopyFromMock.mutex.Lock()
	mmCopyFrom.CopyFromMock.callArgs = append(mmCopyFrom.CopyFromMock.callArgs, &mm_params)
	mmCopyFrom.CopyFromMock.mutex.Unlock()

	for _, e := range mmCopyFrom.CopyFromMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCopyFrom.CopyFromMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyFrom.CopyFromMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyFrom.CopyFromMock.defaultExpectation.params
		mm_want_ptrs := mmCopyFrom.CopyFromMock.defaultExpectation.paramPtrs

		mm_got := TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tableName != nil && !minimock.Equal(*mm_want_ptrs.tableName, mm_got.tableName) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter tableName, want: %#v, got: %#v%s\n", *mm_want_ptrs.tableName, mm_got.tableName, minimock.Diff(*mm_want_ptrs.tableName, mm_got.tableName))
			}

			if mm_want_ptrs.columnNames != nil && !minimock.Equal(*mm_want_ptrs.columnNames, mm_got.columnNames) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter columnNames, want: %#v, got: %#v%s\n", *mm_want_ptrs.columnNames, mm_got.columnNames, minimock.Diff(*mm_want_ptrs.columnNames, mm_got.columnNames))
			}

			if mm_want_ptrs.rowSrc != nil && !minimock.Equal(*mm_want_ptrs.rowSrc, mm_got.rowSrc) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter rowSrc, want: %#v, got: %#v%s\n", *mm_want_ptrs.rowSrc, mm_got.rowSrc, minimock.Diff(*mm_want_ptrs.rowSrc, mm_got.rowSrc))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyFrom.CopyFromMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyFrom.t.Fatal("No results are set for the TxMock.CopyFrom")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCopyFrom.funcCopyFrom != nil {
		return mmCopyFrom.funcCopyFrom(ctx, tableName, columnNames, rowSrc)
	}
	mmCopyFrom.t.Fatalf("Unexpected call to TxMock.CopyFrom. %v %v %v %v", ctx, tableName, columnNames, rowSrc)
	return
}

// CopyFromAfterCounter returns a count of finished TxMock.CopyFrom invocations
func (mmCopyFrom *TxMock) CopyFromAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.afterCopyFromCounter)
}

// CopyFromBeforeCounter returns a count of TxMock.CopyFrom invocations
func (mmCopyFrom *TxMock) CopyFromBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.beforeCopyFromCounter)
}

// Calls returns a list of arguments used in each call to TxMock.CopyFrom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyFrom *mTxMockCopyFrom) Calls() []*TxMockCopyFromParams {
	mmCopyFrom.mutex.RLock()

	argCopy := make([]*TxMockCopyFromParams, len(mmCopyFrom.callArgs))
	copy(argCopy, mmCopyFrom.callArgs)

	mmCopyFrom.mutex.RUnlock()

	return argCopy
}

// MinimockCopyFromDone returns true if the count of the CopyFrom invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockCopyFromDone() bool {
	if m.CopyFromMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CopyFromMock.invocationsDone()
}

// MinimockCopyFromInspect logs each unmet expectation
func (m *TxMock) MinimockCopyFromInspect() {
	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.CopyFrom with params: %#v", *e.params)
		}
	}

	afterCopyFromCounter := mm_atomic.LoadUint64(&m.afterCopyFromCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CopyFromMock.defaultExpectation != nil && afterCopyFromCounter < 1 {
		if m.CopyFromMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.CopyFrom")
		} else {
			m.t.Errorf("Expected call to TxMock.CopyFrom with params: %#v", *m.CopyFromMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyFrom != nil && afterCopyFromCounter < 1 {
		m.t.Error("Expected call to TxMock.CopyFrom")
	}

	if !m.CopyFromMock.invocationsDone() && afterCopyFromCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.CopyFrom but found %d calls",
			mm_atomic.LoadUint64(&m.CopyFromMock.expectedInvocations), afterCopyFromCounter)
	}
}

type mTxMockExec struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockExecExpectation
	expectations       []*TxMockExecExpectation

	callArgs []*TxMockExecParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockExecExpectation specifies expectation struct of the Tx.Exec
type TxMockExecExpectation struct {
	mock      *TxMock
	params    *TxMockExecParams
	paramPtrs *TxMockExecParamPtrs
	results   *TxMockExecResults
	Counter   uint64
}

// TxMockExecParams contains parameters of the Tx.Exec
type TxMockExecParams struct {
	ctx       context.Context
	sql       string
	arguments []interface{}
}

// TxMockExecParamPtrs contains pointers to parameters of the Tx.Exec
type TxMockExecParamPtrs struct {
	ctx       *context.Context
	sql       *string
	arguments *[]interface{}
}

// TxMockExecResults contains results of the Tx.Exec
type TxMockExecResults struct {
	commandTag pgconn.CommandTag
	err        error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExec *mTxMockExec) Optional() *mTxMockExec {
	mmExec.optional = true
	return mmExec
}

// Expect sets up expected params for Tx.Exec
func (mmExec *mTxMockExec) Expect(ctx context.Context, sql string, arguments ...interface{}) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.paramPtrs != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by ExpectParams functions")
	}

	mmExec.defaultExpectation.params = &TxMockExecParams{ctx, sql, arguments}
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Exec
func (mmExec *mTxMockExec) ExpectCtxParam1(ctx context.Context) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.ctx = &ctx

	return mmExec
}

// ExpectSqlParam2 sets up expected param sql for Tx.Exec
func (mmExec *mTxMockExec) ExpectSqlParam2(sql string) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.sql = &sql

	return mmExec
}

// ExpectArgumentsParam3 sets up expected param arguments for Tx.Exec
func (mmExec *mTxMockExec) ExpectArgumentsParam3(arguments ...interface{}) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.arguments = &arguments

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the Tx.Exec
func (mmExec *mTxMockExec) Inspect(f func(ctx context.Context, sql string, arguments ...interface{})) *mTxMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for TxMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by Tx.Exec
func (mmExec *mTxMockExec) Return(commandTag pgconn.CommandTag, err error) *TxMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &TxMockExecResults{commandTag, err}
	return mmExec.mock
}

// Set uses given function f to mock the Tx.Exec method
func (mmExec *mTxMockExec) Set(f func(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error)) *TxMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the Tx.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the Tx.Exec method")
	}

	mmExec.mock.funcExec = f
	return mmExec.mock
}

// When sets expectation for the Tx.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mTxMockExec) When(ctx context.Context, sql string, arguments ...interface{}) *TxMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	expectation := &TxMockExecExpectation{
		mock:   mmExec.mock,
		params: &TxMockExecParams{ctx, sql, arguments},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up Tx.Exec return parameters for the expectation previously defined by the When method
func (e *TxMockExecExpectation) Then(commandTag pgconn.CommandTag, err error) *TxMock {
	e.results = &TxMockExecResults{commandTag, err}
	return e.mock
}

// Times sets number of times Tx.Exec should be invoked
func (mmExec *mTxMockExec) Times(n uint64) *mTxMockExec {
	if n == 0 {
		mmExec.mock.t.Fatalf("Times of TxMock.Exec mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExec.expectedInvocations, n)
	return mmExec
}

func (mmExec *mTxMockExec) invocationsDone() bool {
	if len(mmExec.expectations) == 0 && mmExec.defaultExpectation == nil && mmExec.mock.funcExec == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExec.mock.afterExecCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExec.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Exec implements db.Tx
func (mmExec *TxMock) Exec(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, sql, arguments...)
	}

	mm_params := TxMockExecParams{ctx, sql, arguments}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, &mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.commandTag, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_want_ptrs := mmExec.ExecMock.defaultExpectation.paramPtrs

		mm_got := TxMockExecParams{ctx, sql, arguments}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExec.t.Errorf("TxMock.Exec got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmExec.t.Errorf("TxMock.Exec got unexpected parameter sql, want: %#v, got: %#v%s\n", *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.arguments != nil && !minimock.Equal(*mm_want_ptrs.arguments, mm_got.arguments) {
				mmExec.t.Errorf("TxMock.Exec got unexpected parameter arguments, want: %#v, got: %#v%s\n", *mm_want_ptrs.arguments, mm_got.arguments, minimock.Diff(*mm_want_ptrs.arguments, mm_got.arguments))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("TxMock.Exec got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the TxMock.Exec")
		}
		return (*mm_results).commandTag, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, sql, arguments...)
	}
	mmExec.t.Fatalf("Unexpected call to TxMock.Exec. %v %v %v", ctx, sql, arguments)
	return
}

// ExecAfterCounter returns a count of finished TxMock.Exec invocations
func (mmExec *TxMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of TxMock.Exec invocations
func (mmExec *TxMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mTxMockExec) Calls() []*TxMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*TxMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockExecDone() bool {
	if m.ExecMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecMock.invocationsDone()
}

// MinimockExecInspect logs each unmet expectation
func (m *TxMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Exec with params: %#v", *e.params)
		}
	}

	afterExecCounter := mm_atomic.LoadUint64(&m.afterExecCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && afterExecCounter < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Exec")
		} else {
			m.t.Errorf("Expected call to TxMock.Exec with params: %#v", *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && afterExecCounter < 1 {
		m.t.Error("Expected call to TxMock.Exec")
	}

	if !m.ExecMock.invocationsDone() && afterExecCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Exec but found %d calls",
			mm_atomic.LoadUint64(&m.ExecMock.expectedInvocations), afterExecCounter)
	}
}

type mTxMockLargeObjects struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockLargeObjectsExpectation
	expectations       []*TxMockLargeObjectsExpectation

	expectedInvocations uint64
}

// TxMockLargeObjectsExpectation specifies expectation struct of the Tx.LargeObjects
type TxMockLargeObjectsExpectation struct {
	mock *TxMock

	results *TxMockLargeObjectsResults
	Counter uint64
}

// TxMockLargeObjectsResults contains results of the Tx.LargeObjects
type TxMockLargeObjectsResults struct {
	l1 pgx.LargeObjects
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLargeObjects *mTxMockLargeObjects) Optional() *mTxMockLargeObjects {
	mmLargeObjects.optional = true
	return mmLargeObjects
}

// Expect sets up expected params for Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Expect() *mTxMockLargeObjects {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("TxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &TxMockLargeObjectsExpectation{}
	}

	return mmLargeObjects
}

// Inspect accepts an inspector function that has same arguments as the Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Inspect(f func()) *mTxMockLargeObjects {
	if mmLargeObjects.mock.inspectFuncLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("Inspect function is already set for TxMock.LargeObjects")
	}

	mmLargeObjects.mock.inspectFuncLargeObjects = f

	return mmLargeObjects
}

// Return sets up results that will be returned by Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Return(l1 pgx.LargeObjects) *TxMock {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("TxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &TxMockLargeObjectsExpectation{mock: mmLargeObjects.mock}
	}
	mmLargeObjects.defaultExpectation.results = &TxMockLargeObjectsResults{l1}
	return mmLargeObjects.mock
}

// Set uses given function f to mock the Tx.LargeObjects method
func (mmLargeObjects *mTxMockLargeObjects) Set(f func() (l1 pgx.LargeObjects)) *TxMock {
	if mmLargeObjects.defaultExpectation != nil {
		mmLargeObjects.mock.t.Fatalf("Default expectation is already set for the Tx.LargeObjects method")
	}

	if len(mmLargeObjects.expectations) > 0 {
		mmLargeObjects.mock.t.Fatalf("Some expectations are already set for the Tx.LargeObjects method")
	}

	mmLargeObjects.mock.funcLargeObjects = f
	return mmLargeObjects.mock
}

// Times sets number of times Tx.LargeObjects should be invoked
func (mmLargeObjects *mTxMockLargeObjects) Times(n uint64) *mTxMockLargeObjects {
	if n == 0 {
		mmLargeObjects.mock.t.Fatalf("Times of TxMock.LargeObjects mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLargeObjects.expectedInvocations, n)
	return mmLargeObjects
}

func (mmLargeObjects *mTxMockLargeObjects) invocationsDone() bool {
	if len(mmLargeObjects.expectations) == 0 && mmLargeObjects.defaultExpectation == nil && mmLargeObjects.mock.funcLargeObjects == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLargeObjects.mock.afterLargeObjectsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLargeObjects.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LargeObjects implements db.Tx
func (mmLargeObjects *TxMock) LargeObjects() (l1 pgx.LargeObjects) {
	mm_atomic.AddUint64(&mmLargeObjects.beforeLargeObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmLargeObjects.afterLargeObjectsCounter, 1)

	if mmLargeObjects.inspectFuncLargeObjects != nil {
		mmLargeObjects.inspectFuncLargeObjects()
	}

	if mmLargeObjects.LargeObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLargeObjects.LargeObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmLargeObjects.LargeObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmLargeObjects.t.Fatal("No results are set for the TxMock.LargeObjects")
		}
		return (*mm_results).l1
	}
	if mmLargeObjects.funcLargeObjects != nil {
		return mmLargeObjects.funcLargeObjects()
	}
	mmLargeObjects.t.Fatalf("Unexpected call to TxMock.LargeObjects.")
	return
}

// LargeObjectsAfterCounter returns a count of finished TxMock.LargeObjects invocations
func (mmLargeObjects *TxMock) LargeObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.afterLargeObjectsCounter)
}

// LargeObjectsBeforeCounter returns a count of TxMock.LargeObjects invocations
func (mmLargeObjects *TxMock) LargeObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.beforeLargeObjectsCounter)
}

// MinimockLargeObjectsDone returns true if the count of the LargeObjects invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockLargeObjectsDone() bool {
	if m.LargeObjectsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LargeObjectsMock.invocationsDone()
}

// MinimockLargeObjectsInspect logs each unmet expectation
func (m *TxMock) MinimockLargeObjectsInspect() {
	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TxMock.LargeObjects")
		}
	}

	afterLargeObjectsCounter := mm_atomic.LoadUint64(&m.afterLargeObjectsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LargeObjectsMock.defaultExpectation != nil && afterLargeObjectsCounter < 1 {
		m.t.Error("Expected call to TxMock.LargeObjects")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLargeObjects != nil && afterLargeObjectsCounter < 1 {
		m.t.Error("Expected call to TxMock.LargeObjects")
	}

	if !m.LargeObjectsMock.invocationsDone() && afterLargeObjectsCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.LargeObjects but found %d calls",
			mm_atomic.LoadUint64(&m.LargeObjectsMock.expectedInvocations), afterLargeObjectsCounter)
	}
}

type mTxMockPrepare struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockPrepareExpectation
	expectations       []*TxMockPrepareExpectation

	callArgs []*TxMockPrepareParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockPrepareExpectation specifies expectation struct of the Tx.Prepare
type TxMockPrepareExpectation struct {
	mock      *TxMock
	params    *TxMockPrepareParams
	paramPtrs *TxMockPrepareParamPtrs
	results   *TxMockPrepareResults
	Counter   uint64
}

// TxMockPrepareParams contains parameters of the Tx.Prepare
type TxMockPrepareParams struct {
	ctx  context.Context
	name string
	sql  string
}

// TxMockPrepareParamPtrs contains pointers to parameters of the Tx.Prepare
type TxMockPrepareParamPtrs struct {
	ctx  *context.Context
	name *string
	sql  *string
}

// TxMockPrepareResults contains results of the Tx.Prepare
type TxMockPrepareResults struct {
	sp1 *pgconn.StatementDescription
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrepare *mTxMockPrepare) Optional() *mTxMockPrepare {
	mmPrepare.optional = true
	return mmPrepare
}

// Expect sets up expected params for Tx.Prepare
func (mmPrepare *mTxMockPrepare) Expect(ctx context.Context, name string, sql string) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.paramPtrs != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by ExpectParams functions")
	}

	mmPrepare.defaultExpectation.params = &TxMockPrepareParams{ctx, name, sql}
	for _, e := range mmPrepare.expectations {
		if minimock.Equal(e.params, mmPrepare.defaultExpectation.params) {
			mmPrepare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepare.defaultExpectation.params)
		}
	}

	return mmPrepare
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Prepare
func (mmPrepare *mTxMockPrepare) ExpectCtxParam1(ctx context.Context) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.ctx = &ctx

	return mmPrepare
}

// ExpectNameParam2 sets up expected param name for Tx.Prepare
func (mmPrepare *mTxMockPrepare) ExpectNameParam2(name string) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.name = &name

	return mmPrepare
}

// ExpectSqlParam3 sets up expected param sql for Tx.Prepare
func (mmPrepare *mTxMockPrepare) ExpectSqlParam3(sql string) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.sql = &sql

	return mmPrepare
}

// Inspect accepts an inspector function that has same arguments as the Tx.Prepare
func (mmPrepare *mTxMockPrepare) Inspect(f func(ctx context.Context, name string, sql string)) *mTxMockPrepare {
	if mmPrepare.mock.inspectFuncPrepare != nil {
		mmPrepare.mock.t.Fatalf("Inspect function is already set for TxMock.Prepare")
	}

	mmPrepare.mock.inspectFuncPrepare = f

	return mmPrepare
}

// Return sets up results that will be returned by Tx.Prepare
func (mmPrepare *mTxMockPrepare) Return(sp1 *pgconn.StatementDescription, err error) *TxMock {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{mock: mmPrepare.mock}
	}
	mmPrepare.defaultExpectation.results = &TxMockPrepareResults{sp1, err}
	return mmPrepare.mock
}

// Set uses given function f to mock the Tx.Prepare method
func (mmPrepare *mTxMockPrepare) Set(f func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)) *TxMock {
	if mmPrepare.defaultExpectation != nil {
		mmPrepare.mock.t.Fatalf("Default expectation is already set for the Tx.Prepare method")
	}

	if len(mmPrepare.expectations) > 0 {
		mmPrepare.mock.t.Fatalf("Some expectations are already set for the Tx.Prepare method")
	}

	mmPrepare.mock.funcPrepare = f
	return mmPrepare.mock
}

// When sets expectation for the Tx.Prepare which will trigger the result defined by the following
// Then helper
func (mmPrepare *mTxMockPrepare) When(ctx context.Context, name string, sql string) *TxMockPrepareExpectation {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	expectation := &TxMockPrepareExpectation{
		mock:   mmPrepare.mock,
		params: &TxMockPrepareParams{ctx, name, sql},
	}
	mmPrepare.expectations = append(mmPrepare.expectations, expectation)
	return expectation
}

// Then sets up Tx.Prepare return parameters for the expectation previously defined by the When method
func (e *TxMockPrepareExpectation) Then(sp1 *pgconn.StatementDescription, err error) *TxMock {
	e.results = &TxMockPrepareResults{sp1, err}
	return e.mock
}

// Times sets number of times Tx.Prepare should be invoked
func (mmPrepare *mTxMockPrepare) Times(n uint64) *mTxMockPrepare {
	if n == 0 {
		mmPrepare.mock.t.Fatalf("Times of TxMock.Prepare mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrepare.expectedInvocations, n)
	return mmPrepare
}

func (mmPrepare *mTxMockPrepare) invocationsDone() bool {
	if len(mmPrepare.expectations) == 0 && mmPrepare.defaultExpectation == nil && mmPrepare.mock.funcPrepare == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrepare.mock.afterPrepareCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrepare.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Prepare implements db.Tx
func (mmPrepare *TxMock) Prepare(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error) {
	mm_atomic.AddUint64(&mmPrepare.beforePrepareCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepare.afterPrepareCounter, 1)

	if mmPrepare.inspectFuncPrepare != nil {
		mmPrepare.inspectFuncPrepare(ctx, name, sql)
	}

	mm_params := TxMockPrepareParams{ctx, name, sql}

	// Record call args
	mmPrepare.PrepareMock.mutex.Lock()
	mmPrepare.PrepareMock.callArgs = append(mmPrepare.PrepareMock.callArgs, &mm_params)
	mmPrepare.PrepareMock.mutex.Unlock()

	for _, e := range mmPrepare.PrepareMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmPrepare.PrepareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepare.PrepareMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepare.PrepareMock.defaultExpectation.params
		mm_want_ptrs := mmPrepare.PrepareMock.defaultExpectation.paramPtrs

		mm_got := TxMockPrepareParams{ctx, name, sql}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameter sql, want: %#v, got: %#v%s\n", *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrepare.PrepareMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepare.t.Fatal("No results are set for the TxMock.Prepare")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmPrepare.funcPrepare != nil {
		return mmPrepare.funcPrepare(ctx, name, sql)
	}
	mmPrepare.t.Fatalf("Unexpected call to TxMock.Prepare. %v %v %v", ctx, name, sql)
	return
}

// PrepareAfterCounter returns a count of finished TxMock.Prepare invocations
func (mmPrepare *TxMock) PrepareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.afterPrepareCounter)
}

// PrepareBeforeCounter returns a count of TxMock.Prepare invocations
func (mmPrepare *TxMock) PrepareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.beforePrepareCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Prepare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepare *mTxMockPrepare) Calls() []*TxMockPrepareParams {
	mmPrepare.mutex.RLock()

	argCopy := make([]*TxMockPrepareParams, len(mmPrepare.callArgs))
	copy(argCopy, mmPrepare.callArgs)

	mmPrepare.mutex.RUnlock()

	return argCopy
}

// MinimockPrepareDone returns true if the count of the Prepare invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockPrepareDone() bool {
	if m.PrepareMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrepareMock.invocationsDone()
}

// MinimockPrepareInspect logs each unmet expectation
func (m *TxMock) MinimockPrepareInspect() {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Prepare with params: %#v", *e.params)
		}
	}

	afterPrepareCounter := mm_atomic.LoadUint64(&m.afterPrepareCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && afterPrepareCounter < 1 {
		if m.PrepareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Prepare")
		} else {
			m.t.Errorf("Expected call to TxMock.Prepare with params: %#v", *m.PrepareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && afterPrepareCounter < 1 {
		m.t.Error("Expected call to TxMock.Prepare")
	}

	if !m.PrepareMock.invocationsDone() && afterPrepareCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Prepare but found %d calls",
			mm_atomic.LoadUint64(&m.PrepareMock.expectedInvocations), afterPrepareCounter)
	}
}

type mTxMockQuery struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockQueryExpectation
	expectations       []*TxMockQueryExpectation

	callArgs []*TxMockQueryParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockQueryExpectation specifies expectation struct of the Tx.Query
type TxMockQueryExpectation struct {
	mock      *TxMock
	params    *TxMockQueryParams
	paramPtrs *TxMockQueryParamPtrs
	results   *TxMockQueryResults
	Counter   uint64
}

// TxMockQueryParams contains parameters of the Tx.Query
type TxMockQueryParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// TxMockQueryParamPtrs contains pointers to parameters of the Tx.Query
type TxMockQueryParamPtrs struct {
	ctx  *context.Context
	sql  *string
	args *[]interface{}
}

// TxMockQueryResults contains results of the Tx.Query
type TxMockQueryResults struct {
	r1  pgx.Rows
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQuery *mTxMockQuery) Optional() *mTxMockQuery {
	mmQuery.optional = true
	return mmQuery
}

// Expect sets up expected params for Tx.Query
func (mmQuery *mTxMockQuery) Expect(ctx context.Context, sql string, args ...interface{}) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.paramPtrs != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by ExpectParams functions")
	}

	mmQuery.defaultExpectation.params = &TxMockQueryParams{ctx, sql, args}
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Query
func (mmQuery *mTxMockQuery) ExpectCtxParam1(ctx context.Context) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.ctx = &ctx

	return mmQuery
}

// ExpectSqlParam2 sets up expected param sql for Tx.Query
func (mmQuery *mTxMockQuery) ExpectSqlParam2(sql string) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.sql = &sql

	return mmQuery
}

// ExpectArgsParam3 sets up expected param args for Tx.Query
func (mmQuery *mTxMockQuery) ExpectArgsParam3(args ...interface{}) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.args = &args

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the Tx.Query
func (mmQuery *mTxMockQuery) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mTxMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for TxMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by Tx.Query
func (mmQuery *mTxMockQuery) Return(r1 pgx.Rows, err error) *TxMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &TxMockQueryResults{r1, err}
	return mmQuery.mock
}

// Set uses given function f to mock the Tx.Query method
func (mmQuery *mTxMockQuery) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Rows, err error)) *TxMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the Tx.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the Tx.Query method")
	}

	mmQuery.mock.funcQuery = f
	return mmQuery.mock
}

// When sets expectation for the Tx.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mTxMockQuery) When(ctx context.Context, sql string, args ...interface{}) *TxMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	expectation := &TxMockQueryExpectation{
		mock:   mmQuery.mock,
		params: &TxMockQueryParams{ctx, sql, args},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up Tx.Query return parameters for the expectation previously defined by the When method
func (e *TxMockQueryExpectation) Then(r1 pgx.Rows, err error) *TxMock {
	e.results = &TxMockQueryResults{r1, err}
	return e.mock
}

// Times sets number of times Tx.Query should be invoked
func (mmQuery *mTxMockQuery) Times(n uint64) *mTxMockQuery {
	if n == 0 {
		mmQuery.mock.t.Fatalf("Times of TxMock.Query mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQuery.expectedInvocations, n)
	return mmQuery
}

func (mmQuery *mTxMockQuery) invocationsDone() bool {
	if len(mmQuery.expectations) == 0 && mmQuery.defaultExpectation == nil && mmQuery.mock.funcQuery == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQuery.mock.afterQueryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQuery.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Query implements db.Tx
func (mmQuery *TxMock) Query(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, sql, args...)
	}

	mm_params := TxMockQueryParams{ctx, sql, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, &mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_want_ptrs := mmQuery.QueryMock.defaultExpectation.paramPtrs

		mm_got := TxMockQueryParams{ctx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQuery.t.Errorf("TxMock.Query got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQuery.t.Errorf("TxMock.Query got unexpected parameter sql, want: %#v, got: %#v%s\n", *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQuery.t.Errorf("TxMock.Query got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("TxMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the TxMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, sql, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to TxMock.Query. %v %v %v", ctx, sql, args)
	return
}

// QueryAfterCounter returns a count of finished TxMock.Query invocations
func (mmQuery *TxMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of TxMock.Query invocations
func (mmQuery *TxMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mTxMockQuery) Calls() []*TxMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*TxMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockQueryDone() bool {
	if m.QueryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryMock.invocationsDone()
}

// MinimockQueryInspect logs each unmet expectation
func (m *TxMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Query with params: %#v", *e.params)
		}
	}

	afterQueryCounter := mm_atomic.LoadUint64(&m.afterQueryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && afterQueryCounter < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Query")
		} else {
			m.t.Errorf("Expected call to TxMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && afterQueryCounter < 1 {
		m.t.Error("Expected call to TxMock.Query")
	}

	if !m.QueryMock.invocationsDone() && afterQueryCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Query but found %d calls",
			mm_atomic.LoadUint64(&m.QueryMock.expectedInvocations), afterQueryCounter)
	}
}

type mTxMockQueryFunc struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockQueryFuncExpectation
	expectations       []*TxMockQueryFuncExpectation

	callArgs []*TxMockQueryFuncParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockQueryFuncExpectation specifies expectation struct of the Tx.QueryFunc
type TxMockQueryFuncExpectation struct {
	mock      *TxMock
	params    *TxMockQueryFuncParams
	paramPtrs *TxMockQueryFuncParamPtrs
	results   *TxMockQueryFuncResults
	Counter   uint64
}

// TxMockQueryFuncParams contains parameters of the Tx.QueryFunc
type TxMockQueryFuncParams struct {
	ctx   context.Context
	sql   string
	args  []interface{}
	scans []interface{}
	f     func(pgx.QueryFuncRow) error
}

// TxMockQueryFuncParamPtrs contains pointers to parameters of the Tx.QueryFunc
type TxMockQueryFuncParamPtrs struct {
	ctx   *context.Context
	sql   *string
	args  *[]interface{}
	scans *[]interface{}
	f     *func(pgx.QueryFuncRow) error
}

// TxMockQueryFuncResults contains results of the Tx.QueryFunc
type TxMockQueryFuncResults struct {
	c2  pgconn.CommandTag
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryFunc *mTxMockQueryFunc) Optional() *mTxMockQueryFunc {
	mmQueryFunc.optional = true
	return mmQueryFunc
}

// Expect sets up expected params for Tx.QueryFunc
func (mmQueryFunc *mTxMockQueryFunc) Expect(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error) *mTxMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TxMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.paramPtrs != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by ExpectParams functions")
	}

	mmQueryFunc.defaultExpectation.params = &TxMockQueryFuncParams{ctx, sql, args, scans, f}
	for _, e := range mmQueryFunc.expectations {
		if minimock.Equal(e.params, mmQueryFunc.defaultExpectation.params) {
			mmQueryFunc.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryFunc.defaultExpectation.params)
		}
	}

	return mmQueryFunc
}

// ExpectCtxParam1 sets up expected param ctx for Tx.QueryFunc
func (mmQueryFunc *mTxMockQueryFunc) ExpectCtxParam1(ctx context.Context) *mTxMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TxMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.params != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Expect")
	}

	if mmQueryFunc.defaultExpectation.paramPtrs == nil {
		mmQueryFunc.defaultExpectation.paramPtrs = &TxMockQueryFuncParamPtrs{}
	}
	mmQueryFunc.defaultExpectation.paramPtrs.ctx = &ctx

	return mmQueryFunc
}

// ExpectSqlParam2 sets up expected param sql for Tx.QueryFunc
func (mmQueryFunc *mTxMockQueryFunc) ExpectSqlParam2(sql string) *mTxMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TxMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.params != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Expect")
	}

	if mmQueryFunc.defaultExpectation.paramPtrs == nil {
		mmQueryFunc.defaultExpectation.paramPtrs = &TxMockQueryFuncParamPtrs{}
	}
	mmQueryFunc.defaultExpectation.paramPtrs.sql = &sql

	return mmQueryFunc
}

// ExpectArgsParam3 sets up expected param args for Tx.QueryFunc
func (mmQueryFunc *mTxMockQueryFunc) ExpectArgsParam3(args []interface{}) *mTxMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TxMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.params != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Expect")
	}

	if mmQueryFunc.defaultExpectation.paramPtrs == nil {
		mmQueryFunc.defaultExpectation.paramPtrs = &TxMockQueryFuncParamPtrs{}
	}
	mmQueryFunc.defaultExpectation.paramPtrs.args = &args

	return mmQueryFunc
}

// ExpectScansParam4 sets up expected param scans for Tx.QueryFunc
func (mmQueryFunc *mTxMockQueryFunc) ExpectScansParam4(scans []interface{}) *mTxMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TxMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.params != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Expect")
	}

	if mmQueryFunc.defaultExpectation.paramPtrs == nil {
		mmQueryFunc.defaultExpectation.paramPtrs = &TxMockQueryFuncParamPtrs{}
	}
	mmQueryFunc.defaultExpectation.paramPtrs.scans = &scans

	return mmQueryFunc
}

// ExpectFParam5 sets up expected param f for Tx.QueryFunc
func (mmQueryFunc *mTxMockQueryFunc) ExpectFParam5(f func(pgx.QueryFuncRow) error) *mTxMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TxMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.params != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Expect")
	}

	if mmQueryFunc.defaultExpectation.paramPtrs == nil {
		mmQueryFunc.defaultExpectation.paramPtrs = &TxMockQueryFuncParamPtrs{}
	}
	mmQueryFunc.defaultExpectation.paramPtrs.f = &f

	return mmQueryFunc
}

// Inspect accepts an inspector function that has same arguments as the Tx.QueryFunc
func (mmQueryFunc *mTxMockQueryFunc) Inspect(f func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error)) *mTxMockQueryFunc {
	if mmQueryFunc.mock.inspectFuncQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("Inspect function is already set for TxMock.QueryFunc")
	}

	mmQueryFunc.mock.inspectFuncQueryFunc = f

	return mmQueryFunc
}

// Return sets up results that will be returned by Tx.QueryFunc
func (mmQueryFunc *mTxMockQueryFunc) Return(c2 pgconn.CommandTag, err error) *TxMock {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TxMockQueryFuncExpectation{mock: mmQueryFunc.mock}
	}
	mmQueryFunc.defaultExpectation.results = &TxMockQueryFuncResults{c2, err}
	return mmQueryFunc.mock
}

// Set uses given function f to mock the Tx.QueryFunc method
func (mmQueryFunc *mTxMockQueryFunc) Set(f func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error)) *TxMock {
	if mmQueryFunc.defaultExpectation != nil {
		mmQueryFunc.mock.t.Fatalf("Default expectation is already set for the Tx.QueryFunc method")
	}

	if len(mmQueryFunc.expectations) > 0 {
		mmQueryFunc.mock.t.Fatalf("Some expectations are already set for the Tx.QueryFunc method")
	}

	mmQueryFunc.mock.funcQueryFunc = f
	return mmQueryFunc.mock
}

// When sets expectation for the Tx.QueryFunc which will trigger the result defined by the following
// Then helper
func (mmQueryFunc *mTxMockQueryFunc) When(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error) *TxMockQueryFuncExpectation {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Set")
	}

	expectation := &TxMockQueryFuncExpectation{
		mock:   mmQueryFunc.mock,
		params: &TxMockQueryFuncParams{ctx, sql, args, scans, f},
	}
	mmQueryFunc.expectations = append(mmQueryFunc.expectations, expectation)
	return expectation
}

// Then sets up Tx.QueryFunc return parameters for the expectation previously defined by the When method
func (e *TxMockQueryFuncExpectation) Then(c2 pgconn.CommandTag, err error) *TxMock {
	e.results = &TxMockQueryFuncResults{c2, err}
	return e.mock
}

// Times sets number of times Tx.QueryFunc should be invoked
func (mmQueryFunc *mTxMockQueryFunc) Times(n uint64) *mTxMockQueryFunc {
	if n == 0 {
		mmQueryFunc.mock.t.Fatalf("Times of TxMock.QueryFunc mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryFunc.expectedInvocations, n)
	return mmQueryFunc
}

func (mmQueryFunc *mTxMockQueryFunc) invocationsDone() bool {
	if len(mmQueryFunc.expectations) == 0 && mmQueryFunc.defaultExpectation == nil && mmQueryFunc.mock.funcQueryFunc == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryFunc.mock.afterQueryFuncCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryFunc.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryFunc implements db.Tx
func (mmQueryFunc *TxMock) QueryFunc(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmQueryFunc.beforeQueryFuncCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryFunc.afterQueryFuncCounter, 1)

	if mmQueryFunc.inspectFuncQueryFunc != nil {
		mmQueryFunc.inspectFuncQueryFunc(ctx, sql, args, scans, f)
	}

	mm_params := TxMockQueryFuncParams{ctx, sql, args, scans, f}

	// Record call args
	mmQueryFunc.QueryFuncMock.mutex.Lock()
	mmQueryFunc.QueryFuncMock.callArgs = append(mmQueryFunc.QueryFuncMock.callArgs, &mm_params)
	mmQueryFunc.QueryFuncMock.mutex.Unlock()

	for _, e := range mmQueryFunc.QueryFuncMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmQueryFunc.QueryFuncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryFunc.QueryFuncMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryFunc.QueryFuncMock.defaultExpectation.params
		mm_want_ptrs := mmQueryFunc.QueryFuncMock.defaultExpectation.paramPtrs

		mm_got := TxMockQueryFuncParams{ctx, sql, args, scans, f}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryFunc.t.Errorf("TxMock.QueryFunc got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQueryFunc.t.Errorf("TxMock.QueryFunc got unexpected parameter sql, want: %#v, got: %#v%s\n", *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryFunc.t.Errorf("TxMock.QueryFunc got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

			if mm_want_ptrs.scans != nil && !minimock.Equal(*mm_want_ptrs.scans, mm_got.scans) {
				mmQueryFunc.t.Errorf("TxMock.QueryFunc got unexpected parameter scans, want: %#v, got: %#v%s\n", *mm_want_ptrs.scans, mm_got.scans, minimock.Diff(*mm_want_ptrs.scans, mm_got.scans))
			}

			if mm_want_ptrs.f != nil && !minimock.Equal(*mm_want_ptrs.f, mm_got.f) {
				mmQueryFunc.t.Errorf("TxMock.QueryFunc got unexpected parameter f, want: %#v, got: %#v%s\n", *mm_want_ptrs.f, mm_got.f, minimock.Diff(*mm_want_ptrs.f, mm_got.f))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryFunc.t.Errorf("TxMock.QueryFunc got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryFunc.QueryFuncMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryFunc.t.Fatal("No results are set for the TxMock.QueryFunc")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmQueryFunc.funcQueryFunc != nil {
		return mmQueryFunc.funcQueryFunc(ctx, sql, args, scans, f)
	}
	mmQueryFunc.t.Fatalf("Unexpected call to TxMock.QueryFunc. %v %v %v %v %v", ctx, sql, args, scans, f)
	return
}

// QueryFuncAfterCounter returns a count of finished TxMock.QueryFunc invocations
func (mmQueryFunc *TxMock) QueryFuncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryFunc.afterQueryFuncCounter)
}

// QueryFuncBeforeCounter returns a count of TxMock.QueryFunc invocations
func (mmQueryFunc *TxMock) QueryFuncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryFunc.beforeQueryFuncCounter)
}

// Calls returns a list of arguments used in each call to TxMock.QueryFunc.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryFunc *mTxMockQueryFunc) Calls() []*TxMockQueryFuncParams {
	mmQueryFunc.mutex.RLock()

	argCopy := make([]*TxMockQueryFuncParams, len(mmQueryFunc.callArgs))
	copy(argCopy, mmQueryFunc.callArgs)

	mmQueryFunc.mutex.RUnlock()

	return argCopy
}

// MinimockQueryFuncDone returns true if the count of the QueryFunc invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockQueryFuncDone() bool {
	if m.QueryFuncMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryFuncMock.invocationsDone()
}

// MinimockQueryFuncInspect logs each unmet expectation
func (m *TxMock) MinimockQueryFuncInspect() {
	for _, e := range m.QueryFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.QueryFunc with params: %#v", *e.params)
		}
	}

	afterQueryFuncCounter := mm_atomic.LoadUint64(&m.afterQueryFuncCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryFuncMock.defaultExpectation != nil && afterQueryFuncCounter < 1 {
		if m.QueryFuncMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.QueryFunc")
		} else {
			m.t.Errorf("Expected call to TxMock.QueryFunc with params: %#v", *m.QueryFuncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryFunc != nil && afterQueryFuncCounter < 1 {
		m.t.Error("Expected call to TxMock.QueryFunc")
	}

	if !m.QueryFuncMock.invocationsDone() && afterQueryFuncCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.QueryFunc but found %d calls",
			mm_atomic.LoadUint64(&m.QueryFuncMock.expectedInvocations), afterQueryFuncCounter)
	}
}

type mTxMockQueryRow struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockQueryRowExpectation
	expectations       []*TxMockQueryRowExpectation

	callArgs []*TxMockQueryRowParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockQueryRowExpectation specifies expectation struct of the Tx.QueryRow
type TxMockQueryRowExpectation struct {
	mock      *TxMock
	params    *TxMockQueryRowParams
	paramPtrs *TxMockQueryRowParamPtrs
	results   *TxMockQueryRowResults
	Counter   uint64
}

// TxMockQueryRowParams contains parameters of the Tx.QueryRow
type TxMockQueryRowParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// TxMockQueryRowParamPtrs contains pointers to parameters of the Tx.QueryRow
type TxMockQueryRowParamPtrs struct {
	ctx  *context.Context
	sql  *string
	args *[]interface{}
}

// TxMockQueryRowResults contains results of the Tx.QueryRow
type TxMockQueryRowResults struct {
	r1 pgx.Row
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryRow *mTxMockQueryRow) Optional() *mTxMockQueryRow {
	mmQueryRow.optional = true
	return mmQueryRow
}

// Expect sets up expected params for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Expect(ctx context.Context, sql string, args ...interface{}) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.paramPtrs != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by ExpectParams functions")
	}

	mmQueryRow.defaultExpectation.params = &TxMockQueryRowParams{ctx, sql, args}
	for _, e := range mmQueryRow.expectations {
		if minimock.Equal(e.params, mmQueryRow.defaultExpectation.params) {
			mmQueryRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRow.defaultExpectation.params)
		}
	}

	return mmQueryRow
}

// ExpectCtxParam1 sets up expected param ctx for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) ExpectCtxParam1(ctx context.Context) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.ctx = &ctx

	return mmQueryRow
}

// ExpectSqlParam2 sets up expected param sql for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) ExpectSqlParam2(sql string) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.sql = &sql

	return mmQueryRow
}

// ExpectArgsParam3 sets up expected param args for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) ExpectArgsParam3(args ...interface{}) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.args = &args

	return mmQueryRow
}

// Inspect accepts an inspector function that has same arguments as the Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mTxMockQueryRow {
	if mmQueryRow.mock.inspectFuncQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("Inspect function is already set for TxMock.QueryRow")
	}

	mmQueryRow.mock.inspectFuncQueryRow = f

	return mmQueryRow
}

// Return sets up results that will be returned by Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Return(r1 pgx.Row) *TxMock {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{mock: mmQueryRow.mock}
	}
	mmQueryRow.defaultExpectation.results = &TxMockQueryRowResults{r1}
	return mmQueryRow.mock
}

// Set uses given function f to mock the Tx.QueryRow method
func (mmQueryRow *mTxMockQueryRow) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row)) *TxMock {
	if mmQueryRow.defaultExpectation != nil {
		mmQueryRow.mock.t.Fatalf("Default expectation is already set for the Tx.QueryRow method")
	}

	if len(mmQueryRow.expectations) > 0 {
		mmQueryRow.mock.t.Fatalf("Some expectations are already set for the Tx.QueryRow method")
	}

	mmQueryRow.mock.funcQueryRow = f
	return mmQueryRow.mock
}

// When sets expectation for the Tx.QueryRow which will trigger the result defined by the following
// Then helper
func (mmQueryRow *mTxMockQueryRow) When(ctx context.Context, sql string, args ...interface{}) *TxMockQueryRowExpectation {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	expectation := &TxMockQueryRowExpectation{
		mock:   mmQueryRow.mock,
		params: &TxMockQueryRowParams{ctx, sql, args},
	}
	mmQueryRow.expectations = append(mmQueryRow.expectations, expectation)
	return expectation
}

// Then sets up Tx.QueryRow return parameters for the expectation previously defined by the When method
func (e *TxMockQueryRowExpectation) Then(r1 pgx.Row) *TxMock {
	e.results = &TxMockQueryRowResults{r1}
	return e.mock
}

// Times sets number of times Tx.QueryRow should be invoked
func (mmQueryRow *mTxMockQueryRow) Times(n uint64) *mTxMockQueryRow {
	if n == 0 {
		mmQueryRow.mock.t.Fatalf("Times of TxMock.QueryRow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryRow.expectedInvocations, n)
	return mmQueryRow
}

func (mmQueryRow *mTxMockQueryRow) invocationsDone() bool {
	if len(mmQueryRow.expectations) == 0 && mmQueryRow.defaultExpectation == nil && mmQueryRow.mock.funcQueryRow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryRow.mock.afterQueryRowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryRow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryRow implements db.Tx
func (mmQueryRow *TxMock) QueryRow(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRow.beforeQueryRowCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRow.afterQueryRowCounter, 1)

	if mmQueryRow.inspectFuncQueryRow != nil {
		mmQueryRow.inspectFuncQueryRow(ctx, sql, args...)
	}

	mm_params := TxMockQueryRowParams{ctx, sql, args}

	// Record call args
	mmQueryRow.QueryRowMock.mutex.Lock()
	mmQueryRow.QueryRowMock.callArgs = append(mmQueryRow.QueryRowMock.callArgs, &mm_params)
	mmQueryRow.QueryRowMock.mutex.Unlock()

	for _, e := range mmQueryRow.QueryRowMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRow.QueryRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRow.QueryRowMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRow.QueryRowMock.defaultExpectation.params
		mm_want_ptrs := mmQueryRow.QueryRowMock.defaultExpectation.paramPtrs

		mm_got := TxMockQueryRowParams{ctx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameter sql, want: %#v, got: %#v%s\n", *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRow.QueryRowMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRow.t.Fatal("No results are set for the TxMock.QueryRow")
		}
		return (*mm_results).r1
	}
	if mmQueryRow.funcQueryRow != nil {
		return mmQueryRow.funcQueryRow(ctx, sql, args...)
	}
	mmQueryRow.t.Fatalf("Unexpected call to TxMock.QueryRow. %v %v %v", ctx, sql, args)
	return
}

// QueryRowAfterCounter returns a count of finished TxMock.QueryRow invocations
func (mmQueryRow *TxMock) QueryRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.afterQueryRowCounter)
}

// QueryRowBeforeCounter returns a count of TxMock.QueryRow invocations
func (mmQueryRow *TxMock) QueryRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.beforeQueryRowCounter)
}

// Calls returns a list of arguments used in each call to TxMock.QueryRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRow *mTxMockQueryRow) Calls() []*TxMockQueryRowParams {
	mmQueryRow.mutex.RLock()

	argCopy := make([]*TxMockQueryRowParams, len(mmQueryRow.callArgs))
	copy(argCopy, mmQueryRow.callArgs)

	mmQueryRow.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowDone returns true if the count of the QueryRow invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockQueryRowDone() bool {
	if m.QueryRowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryRowMock.invocationsDone()
}

// MinimockQueryRowInspect logs each unmet expectation
func (m *TxMock) MinimockQueryRowInspect() {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.QueryRow with params: %#v", *e.params)
		}
	}

	afterQueryRowCounter := mm_atomic.LoadUint64(&m.afterQueryRowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && afterQueryRowCounter < 1 {
		if m.QueryRowMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.QueryRow")
		} else {
			m.t.Errorf("Expected call to TxMock.QueryRow with params: %#v", *m.QueryRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && afterQueryRowCounter < 1 {
		m.t.Error("Expected call to TxMock.QueryRow")
	}

	if !m.QueryRowMock.invocationsDone() && afterQueryRowCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.QueryRow but found %d calls",
			mm_atomic.LoadUint64(&m.QueryRowMock.expectedInvocations), afterQueryRowCounter)
	}
}

type mTxMockRollback struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockRollbackExpectation
	expectations       []*TxMockRollbackExpectation

	callArgs []*TxMockRollbackParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockRollbackExpectation specifies expectation struct of the Tx.Rollback
type TxMockRollbackExpectation struct {
	mock      *TxMock
	params    *TxMockRollbackParams
	paramPtrs *TxMockRollbackParamPtrs
	results   *TxMockRollbackResults
	Counter   uint64
}

// TxMockRollbackParams contains parameters of the Tx.Rollback
type TxMockRollbackParams struct {
	ctx context.Context
}

// TxMockRollbackParamPtrs contains pointers to parameters of the Tx.Rollback
type TxMockRollbackParamPtrs struct {
	ctx *context.Context
}

// TxMockRollbackResults contains results of the Tx.Rollback
type TxMockRollbackResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRollback *mTxMockRollback) Optional() *mTxMockRollback {
	mmRollback.optional = true
	return mmRollback
}

// Expect sets up expected params for Tx.Rollback
func (mmRollback *mTxMockRollback) Expect(ctx context.Context) *mTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{}
	}

	if mmRollback.defaultExpectation.paramPtrs != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by ExpectParams functions")
	}

	mmRollback.defaultExpectation.params = &TxMockRollbackParams{ctx}
	for _, e := range mmRollback.expectations {
		if minimock.Equal(e.params, mmRollback.defaultExpectation.params) {
			mmRollback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRollback.defaultExpectation.params)
		}
	}

	return mmRollback
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Rollback
func (mmRollback *mTxMockRollback) ExpectCtxParam1(ctx context.Context) *mTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{}
	}

	if mmRollback.defaultExpectation.params != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Expect")
	}

	if mmRollback.defaultExpectation.paramPtrs == nil {
		mmRollback.defaultExpectation.paramPtrs = &TxMockRollbackParamPtrs{}
	}
	mmRollback.defaultExpectation.paramPtrs.ctx = &ctx

	return mmRollback
}

// Inspect accepts an inspector function that has same arguments as the Tx.Rollback
func (mmRollback *mTxMockRollback) Inspect(f func(ctx context.Context)) *mTxMockRollback {
	if mmRollback.mock.inspectFuncRollback != nil {
		mmRollback.mock.t.Fatalf("Inspect function is already set for TxMock.Rollback")
	}

	mmRollback.mock.inspectFuncRollback = f

	return mmRollback
}

// Return sets up results that will be returned by Tx.Rollback
func (mmRollback *mTxMockRollback) Return(err error) *TxMock {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{mock: mmRollback.mock}
	}
	mmRollback.defaultExpectation.results = &TxMockRollbackResults{err}
	return mmRollback.mock
}

// Set uses given function f to mock the Tx.Rollback method
func (mmRollback *mTxMockRollback) Set(f func(ctx context.Context) (err error)) *TxMock {
	if mmRollback.defaultExpectation != nil {
		mmRollback.mock.t.Fatalf("Default expectation is already set for the Tx.Rollback method")
	}

	if len(mmRollback.expectations) > 0 {
		mmRollback.mock.t.Fatalf("Some expectations are already set for the Tx.Rollback method")
	}

	mmRollback.mock.funcRollback = f
	return mmRollback.mock
}

// When sets expectation for the Tx.Rollback which will trigger the result defined by the following
// Then helper
func (mmRollback *mTxMockRollback) When(ctx context.Context) *TxMockRollbackExpectation {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	expectation := &TxMockRollbackExpectation{
		mock:   mmRollback.mock,
		params: &TxMockRollbackParams{ctx},
	}
	mmRollback.expectations = append(mmRollback.expectations, expectation)
	return expectation
}

// Then sets up Tx.Rollback return parameters for the expectation previously defined by the When method
func (e *TxMockRollbackExpectation) Then(err error) *TxMock {
	e.results = &TxMockRollbackResults{err}
	return e.mock
}

// Times sets number of times Tx.Rollback should be invoked
func (mmRollback *mTxMockRollback) Times(n uint64) *mTxMockRollback {
	if n == 0 {
		mmRollback.mock.t.Fatalf("Times of TxMock.Rollback mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRollback.expectedInvocations, n)
	return mmRollback
}

func (mmRollback *mTxMockRollback) invocationsDone() bool {
	if len(mmRollback.expectations) == 0 && mmRollback.defaultExpectation == nil && mmRollback.mock.funcRollback == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRollback.mock.afterRollbackCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRollback.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Rollback implements db.Tx
func (mmRollback *TxMock) Rollback(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmRollback.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRollback.afterRollbackCounter, 1)

	if mmRollback.inspectFuncRollback != nil {
		mmRollback.inspectFuncRollback(ctx)
	}

	mm_params := TxMockRollbackParams{ctx}

	// Record call args
	mmRollback.RollbackMock.mutex.Lock()
	mmRollback.RollbackMock.callArgs = append(mmRollback.RollbackMock.callArgs, &mm_params)
	mmRollback.RollbackMock.mutex.Unlock()

	for _, e := range mmRollback.RollbackMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRollback.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollback.RollbackMock.defaultExpectation.Counter, 1)
		mm_want := mmRollback.RollbackMock.defaultExpectation.params
		mm_want_ptrs := mmRollback.RollbackMock.defaultExpectation.paramPtrs

		mm_got := TxMockRollbackParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRollback.t.Errorf("TxMock.Rollback got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRollback.t.Errorf("TxMock.Rollback got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRollback.RollbackMock.defaultExpectation.results
		if mm_results == nil {
			mmRollback.t.Fatal("No results are set for the TxMock.Rollback")
		}
		return (*mm_results).err
	}
	if mmRollback.funcRollback != nil {
		return mmRollback.funcRollback(ctx)
	}
	mmRollback.t.Fatalf("Unexpected call to TxMock.Rollback. %v", ctx)
	return
}

// RollbackAfterCounter returns a count of finished TxMock.Rollback invocations
func (mmRollback *TxMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of TxMock.Rollback invocations
func (mmRollback *TxMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.beforeRollbackCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Rollback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRollback *mTxMockRollback) Calls() []*TxMockRollbackParams {
	mmRollback.mutex.RLock()

	argCopy := make([]*TxMockRollbackParams, len(mmRollback.callArgs))
	copy(argCopy, mmRollback.callArgs)

	mmRollback.mutex.RUnlock()

	return argCopy
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockRollbackDone() bool {
	if m.RollbackMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RollbackMock.invocationsDone()
}

// MinimockRollbackInspect logs each unmet expectation
func (m *TxMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Rollback with params: %#v", *e.params)
		}
	}

	afterRollbackCounter := mm_atomic.LoadUint64(&m.afterRollbackCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && afterRollbackCounter < 1 {
		if m.RollbackMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Rollback")
		} else {
			m.t.Errorf("Expected call to TxMock.Rollback with params: %#v", *m.RollbackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && afterRollbackCounter < 1 {
		m.t.Error("Expected call to TxMock.Rollback")
	}

	if !m.RollbackMock.invocationsDone() && afterRollbackCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Rollback but found %d calls",
			mm_atomic.LoadUint64(&m.RollbackMock.expectedInvocations), afterRollbackCounter)
	}
}

type mTxMockSendBatch struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockSendBatchExpectation
	expectations       []*TxMockSendBatchExpectation

	callArgs []*TxMockSendBatchParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockSendBatchExpectation specifies expectation struct of the Tx.SendBatch
type TxMockSendBatchExpectation struct {
	mock      *TxMock
	params    *TxMockSendBatchParams
	paramPtrs *TxMockSendBatchParamPtrs
	results   *TxMockSendBatchResults
	Counter   uint64
}

// TxMockSendBatchParams contains parameters of the Tx.SendBatch
type TxMockSendBatchParams struct {
	ctx context.Context
	b   *pgx.Batch
}

// TxMockSendBatchParamPtrs contains pointers to parameters of the Tx.SendBatch
type TxMockSendBatchParamPtrs struct {
	ctx *context.Context
	b   **pgx.Batch
}

// TxMockSendBatchResults contains results of the Tx.SendBatch
type TxMockSendBatchResults struct {
	b1 pgx.BatchResults
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendBatch *mTxMockSendBatch) Optional() *mTxMockSendBatch {
	mmSendBatch.optional = true
	return mmSendBatch
}

// Expect sets up expected params for Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Expect(ctx context.Context, b *pgx.Batch) *mTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.paramPtrs != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by ExpectParams functions")
	}

	mmSendBatch.defaultExpectation.params = &TxMockSendBatchParams{ctx, b}
	for _, e := range mmSendBatch.expectations {
		if minimock.Equal(e.params, mmSendBatch.defaultExpectation.params) {
			mmSendBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBatch.defaultExpectation.params)
		}
	}

	return mmSendBatch
}

// ExpectCtxParam1 sets up expected param ctx for Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) ExpectCtxParam1(ctx context.Context) *mTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &TxMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSendBatch
}

// ExpectBParam2 sets up expected param b for Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) ExpectBParam2(b *pgx.Batch) *mTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &TxMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.b = &b

	return mmSendBatch
}

// Inspect accepts an inspector function that has same arguments as the Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Inspect(f func(ctx context.Context, b *pgx.Batch)) *mTxMockSendBatch {
	if mmSendBatch.mock.inspectFuncSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("Inspect function is already set for TxMock.SendBatch")
	}

	mmSendBatch.mock.inspectFuncSendBatch = f

	return mmSendBatch
}

// Return sets up results that will be returned by Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Return(b1 pgx.BatchResults) *TxMock {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{mock: mmSendBatch.mock}
	}
	mmSendBatch.defaultExpectation.results = &TxMockSendBatchResults{b1}
	return mmSendBatch.mock
}

// Set uses given function f to mock the Tx.SendBatch method
func (mmSendBatch *mTxMockSendBatch) Set(f func(ctx context.Context, b *pgx.Batch) (b1 pgx.BatchResults)) *TxMock {
	if mmSendBatch.defaultExpectation != nil {
		mmSendBatch.mock.t.Fatalf("Default expectation is already set for the Tx.SendBatch method")
	}

	if len(mmSendBatch.expectations) > 0 {
		mmSendBatch.mock.t.Fatalf("Some expectations are already set for the Tx.SendBatch method")
	}

	mmSendBatch.mock.funcSendBatch = f
	return mmSendBatch.mock
}

// When sets expectation for the Tx.SendBatch which will trigger the result defined by the following
// Then helper
func (mmSendBatch *mTxMockSendBatch) When(ctx context.Context, b *pgx.Batch) *TxMockSendBatchExpectation {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	expectation := &TxMockSendBatchExpectation{
		mock:   mmSendBatch.mock,
		params: &TxMockSendBatchParams{ctx, b},
	}
	mmSendBatch.expectations = append(mmSendBatch.expectations, expectation)
	return expectation
}

// Then sets up Tx.SendBatch return parameters for the expectation previously defined by the When method
func (e *TxMockSendBatchExpectation) Then(b1 pgx.BatchResults) *TxMock {
	e.results = &TxMockSendBatchResults{b1}
	return e.mock
}

// Times sets number of times Tx.SendBatch should be invoked
func (mmSendBatch *mTxMockSendBatch) Times(n uint64) *mTxMockSendBatch {
	if n == 0 {
		mmSendBatch.mock.t.Fatalf("Times of TxMock.SendBatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendBatch.expectedInvocations, n)
	return mmSendBatch
}

func (mmSendBatch *mTxMockSendBatch) invocationsDone() bool {
	if len(mmSendBatch.expectations) == 0 && mmSendBatch.defaultExpectation == nil && mmSendBatch.mock.funcSendBatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendBatch.mock.afterSendBatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendBatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendBatch implements db.Tx
func (mmSendBatch *TxMock) SendBatch(ctx context.Context, b *pgx.Batch) (b1 pgx.BatchResults) {
	mm_atomic.AddUint64(&mmSendBatch.beforeSendBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBatch.afterSendBatchCounter, 1)

	if mmSendBatch.inspectFuncSendBatch != nil {
		mmSendBatch.inspectFuncSendBatch(ctx, b)
	}

	mm_params := TxMockSendBatchParams{ctx, b}

	// Record call args
	mmSendBatch.SendBatchMock.mutex.Lock()
	mmSendBatch.SendBatchMock.callArgs = append(mmSendBatch.SendBatchMock.callArgs, &mm_params)
	mmSendBatch.SendBatchMock.mutex.Unlock()

	for _, e := range mmSendBatch.SendBatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmSendBatch.SendBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBatch.SendBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSendBatch.SendBatchMock.defaultExpectation.params
		mm_want_ptrs := mmSendBatch.SendBatchMock.defaultExpectation.paramPtrs

		mm_got := TxMockSendBatchParams{ctx, b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendBatch.t.Errorf("TxMock.SendBatch got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmSendBatch.t.Errorf("TxMock.SendBatch got unexpected parameter b, want: %#v, got: %#v%s\n", *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendBatch.t.Errorf("TxMock.SendBatch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendBatch.SendBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSendBatch.t.Fatal("No results are set for the TxMock.SendBatch")
		}
		return (*mm_results).b1
	}
	if mmSendBatch.funcSendBatch != nil {
		return mmSendBatch.funcSendBatch(ctx, b)
	}
	mmSendBatch.t.Fatalf("Unexpected call to TxMock.SendBatch. %v %v", ctx, b)
	return
}

// SendBatchAfterCounter returns a count of finished TxMock.SendBatch invocations
func (mmSendBatch *TxMock) SendBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.afterSendBatchCounter)
}

// SendBatchBeforeCounter returns a count of TxMock.SendBatch invocations
func (mmSendBatch *TxMock) SendBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.beforeSendBatchCounter)
}

// Calls returns a list of arguments used in each call to TxMock.SendBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBatch *mTxMockSendBatch) Calls() []*TxMockSendBatchParams {
	mmSendBatch.mutex.RLock()

	argCopy := make([]*TxMockSendBatchParams, len(mmSendBatch.callArgs))
	copy(argCopy, mmSendBatch.callArgs)

	mmSendBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSendBatchDone returns true if the count of the SendBatch invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockSendBatchDone() bool {
	if m.SendBatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendBatchMock.invocationsDone()
}

// MinimockSendBatchInspect logs each unmet expectation
func (m *TxMock) MinimockSendBatchInspect() {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.SendBatch with params: %#v", *e.params)
		}
	}

	afterSendBatchCounter := mm_atomic.LoadUint64(&m.afterSendBatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && afterSendBatchCounter < 1 {
		if m.SendBatchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.SendBatch")
		} else {
			m.t.Errorf("Expected call to TxMock.SendBatch with params: %#v", *m.SendBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && afterSendBatchCounter < 1 {
		m.t.Error("Expected call to TxMock.SendBatch")
	}

	if !m.SendBatchMock.invocationsDone() && afterSendBatchCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.SendBatch but found %d calls",
			mm_atomic.LoadUint64(&m.SendBatchMock.expectedInvocations), afterSendBatchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TxMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBeginInspect()

			m.MinimockBeginFuncInspect()

			m.MinimockCommitInspect()

			m.MinimockConnInspect()

			m.MinimockCopyFromInspect()

			m.MinimockExecInspect()

			m.MinimockLargeObjectsInspect()

			m.MinimockPrepareInspect()

			m.MinimockQueryInspect()

			m.MinimockQueryFuncInspect()

			m.MinimockQueryRowInspect()

			m.MinimockRollbackInspect()

			m.MinimockSendBatchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TxMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TxMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockBeginFuncDone() &&
		m.MinimockCommitDone() &&
		m.MinimockConnDone() &&
		m.MinimockCopyFromDone() &&
		m.MinimockExecDone() &&
		m.MinimockLargeObjectsDone() &&
		m.MinimockPrepareDone() &&
		m.MinimockQueryDone() &&
		m.MinimockQueryFuncDone() &&
		m.MinimockQueryRowDone() &&
		m.MinimockRollbackDone() &&
		m.MinimockSendBatchDone()
}
